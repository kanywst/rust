// 'a は「生存期間グループA」というラベル。
// 引数 x, y と戻り値のすべてに 'a をつけることで、
// 「戻り値の寿命は、x と y の寿命が重なっている期間（短い方）に縛られるよ」と契約している。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // コンパイラはこのシグネチャ（定義）だけを見て、
    // 「戻り値の参照先（xかy）が消えた後に、戻り値が使われるミス」を未然に防ぐ。
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    // s1: ヒープに実体がある String。スコープ（mainの終わり）で物理的に解放される。
    let s1 = String::from("abcd");

    // s2: 最初からバイナリに埋まっている &'static str。
    // プログラム終了まで死なない「最強の寿命」を持つが、as_str() せずとも最初から参照（住所）。
    let s2 = "xyz";

    // longest を呼び出す：
    // 1. s1.as_str() で「ヒープの住所」を一時的に借りる。
    // 2. 'a は「s1（短い方）」と「s2（長い方）」の共通期間、つまり「s1の寿命」として確定する。
    let ans = longest(s1.as_str(), s2);

    // ans は s1 の寿命に縛られている。
    // もしこの直前で s1 を手動で drop(s1) したりすると、
    // コンパイラが「ans の有効期限（'a）が切れた！」と判断して、下の println はエラーになる。
    println!("longest: {}", ans);
} // ここでスタックポインタが戻り、s1の掃除当番（所有権）が発動してヒープが解放される。
  // それと同時に、s1 に依存していた 'a グループのすべての参照（ansなど）が論理的に消滅する。

/* 【ここまでの総まとめ】
  - 物理: スタックはポインタを戻すだけ。ヒープは所有者が消える時に片付ける。
  - 論理: 'a (ライフタイム) は、参照が「物理的な掃除」の巻き添えを食わないか見張るための付箋。
  - 結論: Rustは「物理的な掃除」のタイミングを「論理的な付箋」で管理することで、
         安全かつ高速（GCなし）に動いている。
*/
