fn takes_ownership(s: String) {
    // 3. ここで s がメモリ(ヒープ)の「掃除当番」を引き継ぐ
    println!("I took: {}", s);
} // 4. 関数終了。s が掃除当番として、ヒープのメモリを物理的に解放する

fn makes_copy(i: i32) {
    // 7. i はスタック上のコピーなので、元の x とは完全に別個の 5
    println!("i = {}", i);
} // 8. 関数終了。スタック上の i が消えるだけ。掃除するヒープはない

fn main() {
    // --- 所有権とMove（ヒープを使う重いデータ） ---
    let s1 = String::from("hello");

    // 1. .clone() はヒープに「全く同じ分身」を新しく作る重い処理
    //    これを行わないと、s1 の所有権が移動してしまい、後で s1 を使えなくなる
    let s2 = s1.clone();

    // 2. takes_ownership に s2 を渡す。
    //    物理的にはスタック上の「住所」がコピーされるだけだが、
    //    論理的には s2 はここで「使用禁止（廃墟）」になり、二度とアクセスできない
    takes_ownership(s2);

    // --- Copyトレイト（スタックだけで完結する軽いデータ） ---
    let x = 5;

    // 5. i32 は「Copyトレイト」という免罪符を持っている。
    //    関数に渡すとき、Rustは勝手にビットレベルのコピーを生成して渡す。
    makes_copy(x);

    // 6. x は「移動」したのではなく「複製」されただけなので、
    //    所有権を失わず、この行でも元気に使い続けられる！
    println!("still can use x = {}", x);
}

/* 【エンジニアのための復習メモ】
  - スタック: 爆速。サイズ固定。掃除はポインタを戻すだけ（自動）。
  - ヒープ: 自由。サイズ可変。掃除は「所有者」が責任を持って行う。
  - Move: 「掃除当番」のバトンタッチ。元の変数は物理的に中身があっても「論理的」にアクセス禁止。
  - Copy: 数値など軽いデータに許された特権。所有権という概念を無視してポイポイ使い回せる。
*/
